<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>D√©codeur de trames JVS</title>
    <style>
        body {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            background-color: #1e1e1e;
            color: #dcdcdc;
            margin: 0;
            padding: 20px;
            line-height: 1.4;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        h1 {
            color: #569cd6;
            text-align: center;
            border-bottom: 2px solid #569cd6;
            padding-bottom: 10px;
        }
        
        .file-input {
            background-color: #252526;
            border: 1px solid #3c3c3c;
            border-radius: 4px;
            padding: 20px;
            margin-bottom: 20px;
            text-align: center;
        }
        
        input[type="file"] {
            background-color: #3c3c3c;
            color: white;
            border: 1px solid #569cd6;
            padding: 10px 16px;
            border-radius: 4px;
            cursor: pointer;
            margin: 10px;
            min-width: 300px;
        }
        
        input[type="file"]:hover {
            background-color: #404040;
            border-color: #4fc3f7;
        }
        
        .load-button {
            background-color: #0e639c;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            margin: 10px;
            min-width: 150px;
            transition: background-color 0.3s;
        }
        
        .load-button:hover:not(:disabled) {
            background-color: #1177bb;
        }
        
        .load-button:disabled {
            background-color: #666;
            cursor: not-allowed;
            opacity: 0.6;
        }
        
        .file-info {
            margin: 10px 0;
            color: #9cdcfe;
            font-style: italic;
        }
        
        .loading {
            color: #ffd700;
            font-weight: bold;
        }
        
        .stats {
            background-color: #252526;
            border: 1px solid #3c3c3c;
            border-radius: 4px;
            padding: 15px;
            margin-bottom: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }
        
        .stat-item {
            background-color: #2d2d30;
            padding: 10px;
            border-radius: 4px;
        }
        
        .stat-label {
            color: #9cdcfe;
            font-weight: bold;
        }
        
        .frames-container {
            background-color: #252526;
            border: 1px solid #3c3c3c;
            border-radius: 4px;
            min-height: 400px;
        }
        
        .playback-controls {
            background-color: #2d2d30;
            border: 1px solid #3c3c3c;
            border-radius: 4px;
            padding: 15px;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        .control-button {
            background-color: #0e639c;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .control-button:hover:not(:disabled) {
            background-color: #1177bb;
        }
        
        .control-button:disabled {
            background-color: #666;
            cursor: not-allowed;
            opacity: 0.6;
        }
        
        .control-info {
            color: #9cdcfe;
            font-weight: bold;
            margin-left: auto;
        }
        
        .exchange-display {
            background-color: #1e1e1e;
            border: 1px solid #3c3c3c;
            border-radius: 4px;
            padding: 20px;
            min-height: 300px;
        }
        
        .exchange-title {
            color: #569cd6;
            font-size: 1.2em;
            font-weight: bold;
            text-align: center;
            margin-bottom: 20px;
            padding: 10px;
            border-bottom: 2px solid #3c3c3c;
        }
        
        .request-response-pair {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .request-panel, .response-panel {
            background-color: #2d2d30;
            border-radius: 4px;
            padding: 15px;
        }
        
        .request-panel {
            border-left: 4px solid #4caf50;
        }
        
        .response-panel {
            border-left: 4px solid #ff9800;
        }
        
        .panel-title {
            font-weight: bold;
            margin-bottom: 10px;
            text-align: center;
            padding: 8px;
            border-radius: 4px;
        }
        
        .request-title {
            background-color: #2e5d32;
            color: #4caf50;
        }
        
        .response-title {
            background-color: #4d2c00;
            color: #ff9800;
        }
        
        .step-indicator {
            background-color: #3c3c3c;
            color: #9cdcfe;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 0.9em;
            text-align: center;
            margin-bottom: 15px;
        }
        
        .frame {
            border-bottom: 1px solid #3c3c3c;
            padding: 10px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .frame:hover {
            background-color: #2a2a2a;
        }
        
        .frame-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }
        
        .frame-number {
            color: #4fc3f7;
            font-weight: bold;
        }
        
        .frame-type {
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.8em;
            font-weight: bold;
        }
        
        .cmd-type {
            background-color: #4caf50;
            color: white;
        }
        
        .resp-type {
            background-color: #ff9800;
            color: white;
        }
        
        .raw-data {
            color: #ce9178;
            font-size: 0.9em;
            margin: 5px 0;
        }
        
        .decoded-info {
            background-color: #2d2d30;
            border-left: 4px solid #569cd6;
            padding: 8px;
            margin-top: 8px;
            border-radius: 0 4px 4px 0;
        }
        
        .field {
            margin: 3px 0;
        }
        
        .field-name {
            color: #9cdcfe;
            font-weight: bold;
            display: inline-block;
            width: 120px;
        }
        
        .field-value {
            color: #ce9178;
        }
        
        .error {
            color: #f44336;
            background-color: #2d1b1b;
            border: 1px solid #f44336;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
        }
        
        .escape-highlight {
            background-color: #4a4a00;
            color: #ffff00;
            padding: 1px 3px;
            border-radius: 2px;
        }
        
        .checksum-ok {
            color: #4caf50;
        }
        
        .checksum-error {
            color: #f44336;
        }
        
        .node-info-container {
            background-color: #252526;
            border: 1px solid #3c3c3c;
            border-radius: 4px;
            padding: 15px;
            margin: 20px 0;
            display: none;
        }
        
        .node-info-title {
            color: #569cd6;
            font-size: 1.2em;
            font-weight: bold;
            border-bottom: 1px solid #3c3c3c;
            padding-bottom: 8px;
            margin-bottom: 15px;
        }
        
        .node-card {
            background-color: #2d2d30;
            border-radius: 4px;
            padding: 15px;
            margin-bottom: 15px;
            border-left: 4px solid #4caf50;
        }
        
        .node-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .node-name {
            color: #4fc3f7;
            font-weight: bold;
            font-size: 1.1em;
        }
        
        .node-address {
            color: #9cdcfe;
            background-color: #3c3c3c;
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 0.9em;
        }
        
        .capabilities-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        .capability-group {
            background-color: #404040;
            padding: 10px;
            border-radius: 4px;
        }
        
        .capability-title {
            color: #ffd700;
            font-weight: bold;
            margin-bottom: 8px;
            border-bottom: 1px solid #555;
            padding-bottom: 4px;
        }
        
        .capability-item {
            margin: 4px 0;
            color: #e0e0e0;
        }
        
        .capability-value {
            color: #ffb74d;
            font-weight: bold;
        }
        
        .feature-data {
            background-color: #1a1a1a;
            border: 1px solid #444;
            border-radius: 4px;
            padding: 10px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
        }
        
        .feature-block {
            background-color: #2a2a2a;
            border-left: 3px solid #4caf50;
            padding: 5px 10px;
            margin: 5px 0;
        }
        
        .func-code {
            color: #4caf50;
            font-weight: bold;
        }
        
        .func-params {
            color: #ffb74d;
        }
        
        /* Styles pour le highlight des bytes */
        .byte-highlight {
            background-color: #ffd700 !important;
            color: #000 !important;
            padding: 2px 4px;
            border-radius: 3px;
            font-weight: bold;
        }
        
        .result-block:hover {
            background-color: #3d3d3d !important;
            cursor: pointer;
        }
        
        .raw-data .byte {
            padding: 2px 4px;
            border-radius: 2px;
            transition: all 0.2s;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>D√©codeur de trames JVS</h1>
        
        <div class="file-input">
            <h3 style="color: #569cd6; margin-top: 0;">üìÅ Charger un fichier de capture JVS</h3>
            <div style="color: #9cdcfe; margin-bottom: 15px; font-size: 0.9em;">
                S√©lectionnez un fichier de capture JVS (.jvs) pour analyser les trames de communication<br>
                Format support√© : une trame par ligne en hexad√©cimal (ex: E0FF03F101F4)
            </div>
            <input type="file" id="fileInput" accept=".jvs,.txt" />
            <br>
            <div id="fileInfo" class="file-info" style="display: none;"></div>
            <button id="loadButton" class="load-button" disabled onclick="loadFile()">
                Analyser la capture JVS
            </button>
            <button id="clearButton" class="load-button" style="background-color: #666; display: none;" onclick="clearResults()">
                Effacer les r√©sultats
            </button>
            <div id="loadingStatus" style="display: none;"></div>
        </div>
        
        <div id="stats" class="stats" style="display: none;">
            <div class="stat-item">
                <div class="stat-label">Total trames:</div>
                <div id="totalFrames">0</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Commandes:</div>
                <div id="commandFrames">0</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">R√©ponses:</div>
                <div id="responseFrames">0</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Erreurs:</div>
                <div id="errorFrames">0</div>
            </div>
        </div>
        
        <div id="nodeInfoContainer" class="node-info-container">
            <div class="node-info-title">Informations des n≈ìuds JVS</div>
            <div id="nodesList"></div>
        </div>
        
        <div id="framesContainer" class="frames-container" style="display: none;">
            <div class="playback-controls">
                <button id="firstBtn" class="control-button" title="Premier √©change (Home)">
                    ‚èÆÔ∏è Premier
                </button>
                <button id="prevBtn" class="control-button" title="√âchange pr√©c√©dent (‚Üê)">
                    ‚è™ Pr√©c√©dent
                </button>
                <button id="playPauseBtn" class="control-button" title="Lecture automatique (Espace)">
                    ‚ñ∂Ô∏è Lecture auto
                </button>
                <button id="nextBtn" class="control-button" title="√âchange suivant (‚Üí)">
                    Suivant ‚è©
                </button>
                <button id="lastBtn" class="control-button" title="Dernier √©change (End)">
                    Dernier ‚è≠Ô∏è
                </button>
                
                <div class="control-info">
                    <span id="exchangeInfo">√âchange 0 / 0</span>
                    <span style="margin-left: 15px; font-size: 0.9em; color: #888;">
                        Navigation : ‚Üê‚Üí | Espace: lecture auto | Home/End: premier/dernier
                    </span>
                </div>
            </div>
            
            <div id="exchangeDisplay" class="exchange-display">
                <div class="exchange-title">
                    S√©lectionnez un √©change pour commencer
                </div>
                <div style="text-align: center; color: #9cdcfe; margin-top: 50px;">
                    Utilisez les boutons ci-dessus ou les touches fl√©ch√©es pour naviguer dans la capture JVS
                </div>
            </div>
        </div>
    </div>

    <script>
        // Constants JVS bas√©es sur le code source
        const JVS = {
            SYNC_BYTE: 0xE0,
            BROADCAST_ADDR: 0xFF,
            HOST_ADDR: 0x00,
            
            // Commandes
            CMD: {
                0xF0: 'RESET',
                0xF1: 'SETADDR',
                0xF2: 'COMMCHG',
                0x10: 'IOIDENT',
                0x11: 'CMDREV',
                0x12: 'JVSREV', 
                0x13: 'COMMVER',
                0x14: 'FEATCHK',
                0x15: 'MAINID',
                0x20: 'SWINP',
                0x21: 'COININP',
                0x22: 'ANLINP',
                0x23: 'ROTINP',
                0x24: 'KEYINP',
                0x25: 'SCRPOSINP',
                0x26: 'MISCSWINP',
                0x2E: 'PAYCNT',
                0x2F: 'RETRANSMIT',
                0x30: 'COINDEC',
                0x31: 'PAYINC',
                0x32: 'OUTPUT1',
                0x33: 'ANLOUT',
                0x34: 'CHAROUT',
                0x35: 'COININC',
                0x36: 'PAYDEC',
                0x37: 'OUTPUT2',
                0x38: 'OUTPUT3'
            },
            
            // Status codes
            STATUS: {
                0x01: 'NORMAL',
                0x02: 'UNKNOWN_CMD',
                0x03: 'SUM_ERROR',
                0x04: 'ACK_OVERFLOW',
                0x05: 'BUSY'
            },
            
            // Function codes pour Feature Check (bas√© sur jvs_controller.sv)
            FUNC: {
                0x01: { name: 'INPUT_DIGITAL', desc: 'Entr√©es digitales' },
                0x02: { name: 'INPUT_COIN', desc: 'Entr√©es monnaie' },
                0x03: { name: 'INPUT_ANALOG', desc: 'Entr√©es analogiques' },
                0x04: { name: 'INPUT_ROTARY', desc: 'Entr√©es rotatives' },
                0x05: { name: 'INPUT_KEYCODE', desc: 'Entr√©es clavier' },
                0x06: { name: 'INPUT_SCREEN_POS', desc: 'Position √©cran' },
                0x07: { name: 'INPUT_MISC_DIGITAL', desc: 'Entr√©es diverses' },
                0x10: { name: 'OUTPUT_CARD', desc: 'Sortie carte' },
                0x11: { name: 'OUTPUT_HOPPER', desc: 'Sortie distributeur' },
                0x12: { name: 'OUTPUT_DIGITAL', desc: 'Sorties digitales' },
                0x13: { name: 'OUTPUT_ANALOG', desc: 'Sorties analogiques' },
                0x14: { name: 'OUTPUT_CHAR', desc: 'Affichage caract√®res' },
                0x15: { name: 'OUTPUT_BACKUP', desc: 'Support sauvegarde' }
            }
        };
        
        let frames = [];
        let stats = {
            total: 0,
            commands: 0,
            responses: 0,
            errors: 0
        };
        let jvsNodes = []; // Stockage des informations des n≈ìuds JVS
        let selectedFile = null; // Fichier s√©lectionn√©
        let exchanges = []; // Paires requ√™te/r√©ponse
        let currentExchangeIndex = 0; // Index de l'√©change actuel
        let autoPlay = false; // Mode lecture automatique
        let autoPlayInterval = null; // Timer pour lecture automatique
        
        // Attendre que le DOM soit charg√©
        document.addEventListener('DOMContentLoaded', function() {
            const fileInput = document.getElementById('fileInput');
            const loadButton = document.getElementById('loadButton');
            const clearButton = document.getElementById('clearButton');
            
            console.log('DOM loaded, setting up event listeners');
            console.log('File input found:', !!fileInput);
            console.log('Load button found:', !!loadButton);
            
            if (fileInput) {
                fileInput.addEventListener('change', handleFileSelection);
            }
            
            if (loadButton) {
                loadButton.addEventListener('click', loadFile);
            }
            
            if (clearButton) {
                clearButton.addEventListener('click', clearResults);
            }
            
            // Event listeners pour les contr√¥les de navigation
            const firstBtn = document.getElementById('firstBtn');
            const prevBtn = document.getElementById('prevBtn');
            const playPauseBtn = document.getElementById('playPauseBtn');
            const nextBtn = document.getElementById('nextBtn');
            const lastBtn = document.getElementById('lastBtn');
            
            if (firstBtn) firstBtn.addEventListener('click', () => goToExchange(0));
            if (prevBtn) prevBtn.addEventListener('click', () => navigateExchange(-1));
            if (playPauseBtn) playPauseBtn.addEventListener('click', toggleAutoPlay);
            if (nextBtn) nextBtn.addEventListener('click', () => navigateExchange(1));
            if (lastBtn) lastBtn.addEventListener('click', () => goToExchange(exchanges.length - 1));
            
            // Navigation au clavier
            document.addEventListener('keydown', handleKeyNavigation);
        });
        
        function handleFileSelection(event) {
            console.log('File selection triggered');
            const file = event.target.files[0];
            const loadButton = document.getElementById('loadButton');
            const fileInfo = document.getElementById('fileInfo');
            
            console.log('Selected file:', file);
            console.log('Load button found in handler:', !!loadButton);
            
            if (!file) {
                selectedFile = null;
                if (loadButton) {
                    loadButton.disabled = true;
                    loadButton.textContent = 'Analyser la capture JVS';
                }
                if (fileInfo) fileInfo.style.display = 'none';
                return;
            }
            
            selectedFile = file;
            if (loadButton) {
                loadButton.disabled = false;
                loadButton.textContent = 'Analyser la capture JVS';
                console.log('Button enabled');
            }
            
            // Afficher les informations du fichier
            if (fileInfo) {
                const fileSize = (file.size / 1024).toFixed(1);
                fileInfo.innerHTML = `
                    <strong>Fichier s√©lectionn√©:</strong> ${file.name}<br>
                    <strong>Taille:</strong> ${fileSize} KB<br>
                    <strong>Type:</strong> ${file.type || 'Fichier JVS'}
                `;
                fileInfo.style.display = 'block';
            }
        }
        
        function loadFile() {
            if (!selectedFile) return;
            
            const loadButton = document.getElementById('loadButton');
            const loadingStatus = document.getElementById('loadingStatus');
            
            // Afficher le statut de chargement
            loadButton.disabled = true;
            loadButton.textContent = 'Analyse en cours...';
            loadingStatus.innerHTML = '<div class="loading">üîÑ Lecture et d√©codage du fichier...</div>';
            loadingStatus.style.display = 'block';
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    loadingStatus.innerHTML = '<div class="loading">üîÑ Parsing des trames JVS...</div>';
                    
                    // Utiliser setTimeout pour permettre l'affichage du message
                    setTimeout(() => {
                        try {
                            parseJVSFile(e.target.result);
                            
                            loadingStatus.innerHTML = '<div class="loading">üîÑ G√©n√©ration de l\'affichage...</div>';
                            
                            setTimeout(() => {
                                displayFrames();
                                updateStats();
                                
                                // Succ√®s
                                loadingStatus.innerHTML = '<div style="color: #4caf50; font-weight: bold;">‚úÖ Analyse termin√©e avec succ√®s!</div>';
                                loadButton.textContent = 'Analyser une nouvelle capture';
                                loadButton.disabled = false;
                                
                                // Afficher le bouton d'effacement
                                document.getElementById('clearButton').style.display = 'inline-block';
                                
                                // Masquer le message de succ√®s apr√®s 3 secondes
                                setTimeout(() => {
                                    loadingStatus.style.display = 'none';
                                }, 3000);
                                
                            }, 100);
                        } catch (error) {
                            displayError(`Erreur lors du parsing: ${error.message}`);
                            loadButton.textContent = 'R√©essayer l\'analyse';
                            loadButton.disabled = false;
                            loadingStatus.style.display = 'none';
                        }
                    }, 100);
                    
                } catch (error) {
                    displayError(`Erreur lors de la lecture: ${error.message}`);
                    loadButton.textContent = 'R√©essayer l\'analyse';
                    loadButton.disabled = false;
                    loadingStatus.style.display = 'none';
                }
            };
            
            reader.onerror = function() {
                displayError('Erreur lors de la lecture du fichier');
                loadButton.textContent = 'R√©essayer l\'analyse';
                loadButton.disabled = false;
                loadingStatus.style.display = 'none';
            };
            
            reader.readAsText(selectedFile);
        }
        
        function clearResults() {
            // R√©initialiser toutes les donn√©es
            frames = [];
            stats = { total: 0, commands: 0, responses: 0, errors: 0 };
            jvsNodes = [];
            exchanges = [];
            currentExchangeIndex = 0;
            
            // Arr√™ter la lecture automatique si elle est active
            if (autoPlay) {
                toggleAutoPlay();
            }
            
            // Masquer tous les conteneurs de r√©sultats
            document.getElementById('stats').style.display = 'none';
            document.getElementById('nodeInfoContainer').style.display = 'none';
            document.getElementById('framesContainer').style.display = 'none';
            document.getElementById('clearButton').style.display = 'none';
            
            // R√©initialiser l'interface
            const loadButton = document.getElementById('loadButton');
            loadButton.textContent = 'Analyser la capture JVS';
            loadButton.disabled = selectedFile ? false : true;
            
            // Masquer les statuts
            document.getElementById('loadingStatus').style.display = 'none';
        }
        
        function parseJVSFile(content) {
            frames = [];
            stats = { total: 0, commands: 0, responses: 0, errors: 0 };
            jvsNodes = [];
            
            // Convertir le contenu en bytes hexad√©cimaux
            const hexData = content.replace(/\s+/g, '').replace(/\n/g, '').replace(/\r/g, '');
            console.log('Hex data length:', hexData.length);
            console.log('First 100 chars:', hexData.substring(0, 100));
            
            // Valider que c'est bien de l'hexad√©cimal
            if (!/^[0-9A-Fa-f]*$/.test(hexData)) {
                throw new Error('Le fichier ne contient pas de donn√©es hexad√©cimales valides');
            }
            
            if (hexData.length % 2 !== 0) {
                throw new Error('Donn√©es hexad√©cimales de longueur impaire');
            }
            
            // Convertir en tableau de bytes
            const bytes = [];
            for (let i = 0; i < hexData.length; i += 2) {
                const byte = parseInt(hexData.substr(i, 2), 16);
                if (isNaN(byte)) {
                    throw new Error(`Byte invalide √† la position ${i}: ${hexData.substr(i, 2)}`);
                }
                bytes.push(byte);
            }
            
            console.log('Total bytes:', bytes.length);
            console.log('First 20 bytes:', bytes.slice(0, 20).map(b => '0x' + b.toString(16).toUpperCase().padStart(2, '0')).join(' '));
            
            // Parser les trames en utilisant SYNC_BYTE (0xE0) comme d√©limiteur
            let frameNumber = 1;
            let i = 0;
            
            while (i < bytes.length) {
                // Rechercher le prochain SYNC_BYTE
                if (bytes[i] !== 0xE0) {
                    i++;
                    continue;
                }
                
                // D√©but de trame trouv√©
                const frameStart = i;
                
                // V√©rifier qu'on a assez de bytes pour l'en-t√™te minimal (sync + addr + length)
                if (i + 2 >= bytes.length) {
                    console.warn(`Trame incompl√®te √† la position ${i}`);
                    break;
                }
                
                const syncByte = bytes[i];     // E0
                const destAddr = bytes[i + 1]; // Adresse destination
                const length = bytes[i + 2];   // Longueur des donn√©es + checksum
                
                // Calculer la longueur totale de la trame
                const totalFrameLength = 3 + length; // sync + addr + length + donn√©es + checksum
                
                // V√©rifier qu'on a tous les bytes de la trame
                if (i + totalFrameLength > bytes.length) {
                    console.warn(`Trame incompl√®te √† la position ${i}, longueur attendue: ${totalFrameLength}, bytes restants: ${bytes.length - i}`);
                    break;
                }
                
                // Extraire les bytes de la trame
                const frameBytes = bytes.slice(i, i + totalFrameLength);
                
                try {
                    // Convertir en string hex pour parseFrame
                    const hexString = frameBytes.map(b => b.toString(16).toUpperCase().padStart(2, '0')).join('');
                    
                    console.log(`Trame ${frameNumber}: ${hexString}`);
                    
                    const frame = parseFrame(hexString, frameNumber);
                    if (frame) {
                        frames.push(frame);
                        stats.total++;
                        
                        if (frame.type === 'command') stats.commands++;
                        else if (frame.type === 'response') stats.responses++;
                        if (frame.hasError) stats.errors++;
                        
                        // Traitement sp√©cial pour certaines r√©ponses
                        processFrameForNodeInfo(frame);
                    }
                    
                    frameNumber++;
                } catch (error) {
                    console.warn(`Erreur trame ${frameNumber} √† la position ${i}: ${error.message}`);
                    stats.errors++;
                }
                
                // Avancer au byte suivant le checksum
                i += totalFrameLength;
            }
            
            console.log(`Parsing termin√©: ${frames.length} trames trouv√©es`);
        }
        
        function parseFrame(hexString, lineNumber) {
            // Supprimer espaces et pr√©fixes
            hexString = hexString.replace(/\\s+/g, '').replace(/^0x/i, '');
            
            if (hexString.length % 2 !== 0) {
                throw new Error('Cha√Æne hexad√©cimale de longueur impaire');
            }
            
            const rawBytes = [];
            for (let i = 0; i < hexString.length; i += 2) {
                const byte = parseInt(hexString.substr(i, 2), 16);
                if (isNaN(byte)) {
                    throw new Error(`Byte invalide: ${hexString.substr(i, 2)}`);
                }
                rawBytes.push(byte);
            }
            
            if (rawBytes.length < 4) {
                throw new Error('Trame trop courte');
            }
            
            // D√©s√©rialisation des escape sequences
            const unescapedBytes = unescapeJVSData(rawBytes);
            
            const frame = {
                lineNumber,
                rawHex: hexString,
                rawBytes,
                unescapedBytes,
                hasError: false,
                errorMessage: ''
            };
            
            // V√©rification du sync byte
            if (rawBytes[0] !== JVS.SYNC_BYTE) {
                frame.hasError = true;
                frame.errorMessage = `Sync byte invalide: 0x${rawBytes[0].toString(16).toUpperCase()}`;
            }
            
            // Parsing des champs
            frame.sync = rawBytes[0];
            frame.destAddr = rawBytes[1];
            frame.length = rawBytes[2];
            
            // D√©termination du type (commande vs r√©ponse)
            frame.type = frame.destAddr === JVS.BROADCAST_ADDR || frame.destAddr > 0 ? 'command' : 'response';
            
            // Calcul et v√©rification du checksum
            const expectedLength = frame.length + 1; // +1 pour le checksum
            if (unescapedBytes.length !== expectedLength + 2) { // +2 pour sync et dest
                frame.hasError = true;
                frame.errorMessage += ` Longueur incorrecte: attendu ${expectedLength + 2}, re√ßu ${unescapedBytes.length}`;
            }
            
            if (unescapedBytes.length >= 4) {
                // Checksum JVS inclut tous les bytes sauf SYNC_BYTE (E0) et le checksum lui-m√™me
                // Bas√© sur le code FPGA : inclut destination, longueur et toutes les donn√©es
                const checksumBytes = unescapedBytes.slice(1, -1); // Sans sync et sans checksum final
                const receivedChecksum = unescapedBytes[unescapedBytes.length - 1];
                const calculatedChecksum = calculateChecksum(checksumBytes);
                
                frame.checksumReceived = receivedChecksum;
                frame.checksumCalculated = calculatedChecksum;
                frame.checksumValid = receivedChecksum === calculatedChecksum;
                
                if (!frame.checksumValid) {
                    frame.hasError = true;
                    frame.errorMessage += ` Checksum invalide: re√ßu 0x${receivedChecksum.toString(16).toUpperCase()}, calcul√© 0x${calculatedChecksum.toString(16).toUpperCase()}`;
                }
            }
            
            // D√©codage sp√©cifique selon le type
            if (frame.type === 'command') {
                decodeCommand(frame);
            } else {
                decodeResponse(frame);
            }
            
            return frame;
        }
        
        function unescapeJVSData(bytes) {
            const result = [];
            let i = 0;
            
            while (i < bytes.length) {
                if (bytes[i] === 0xD0 && i + 1 < bytes.length) {
                    // Sequence d'escape
                    if (bytes[i + 1] === 0xDF) {
                        result.push(0xE0);
                        i += 2;
                    } else if (bytes[i + 1] === 0xCF) {
                        result.push(0xD0);
                        i += 2;
                    } else {
                        result.push(bytes[i]);
                        i++;
                    }
                } else {
                    result.push(bytes[i]);
                    i++;
                }
            }
            
            return result;
        }
        
        function calculateChecksum(bytes) {
            // Checksum JVS : simple somme des bytes (sans le SYNC_BYTE)
            // Bas√© sur le code jvs_controller.sv : rx_checksum <= rx_checksum + uart_rx_byte
            let sum = 0;
            bytes.forEach(byte => sum += byte);
            return sum & 0xFF; // Retourner seulement les 8 bits de poids faible
        }
        
        function decodeCommand(frame) {
            if (frame.unescapedBytes.length < 4) return;
            
            // Donn√©es de commande (sans sync, dest, length, et checksum)
            const commandData = frame.unescapedBytes.slice(3, -1);
            
            // Une trame JVS peut contenir plusieurs commandes
            frame.commands = [];
            let i = 0;
            
            while (i < commandData.length) {
                const cmdByte = commandData[i];
                const command = {
                    cmdByte: cmdByte,
                    command: JVS.CMD[cmdByte] || `UNK_0x${cmdByte.toString(16).toUpperCase()}`,
                    args: [],
                    details: ''
                };
                
                i++; // Passer au premier argument
                
                // Extraire les arguments selon le type de commande
                const argCount = getCommandArgCount(cmdByte, commandData, i);
                for (let j = 0; j < argCount && i < commandData.length; j++, i++) {
                    command.args.push(commandData[i]);
                }
                
                // D√©codage sp√©cifique par commande
                decodeSpecificCommand(command);
                
                frame.commands.push(command);
            }
            
            // Pour compatibilit√© descendante, si une seule commande, copier dans les champs principaux
            if (frame.commands.length === 1) {
                frame.command = frame.commands[0].command;
                frame.cmdByte = frame.commands[0].cmdByte;
                frame.args = frame.commands[0].args;
                frame.details = frame.commands[0].details;
            } else {
                frame.command = `Multi-commandes (${frame.commands.length})`;
                frame.isMultiCommand = true;
            }
        }
        
        function getCommandArgCount(cmdByte, data, startIdx) {
            // Retourne le nombre d'arguments attendus pour une commande
            switch (cmdByte) {
                case 0xF0: // RESET
                    return 1; // 1 byte d'argument (0xD9)
                case 0xF1: // SETADDR
                    return 1; // 1 byte (nouvelle adresse)
                case 0x20: // SWINP
                    return 2; // 2 bytes (nombre de joueurs, bytes par joueur)
                case 0x21: // COININP
                    return 1; // 1 byte (nombre de slots)
                case 0x22: // ANLINP
                    return 1; // 1 byte (nombre de canaux)
                case 0x23: // ROTINP
                    return 1; // 1 byte (nombre de canaux)
                case 0x24: // KEYINP
                    return 1; // 1 byte (nombre de codes)
                case 0x25: // SCRPOSINP
                    return 1; // 1 byte (canal)
                case 0x26: // MISCSWINP
                    return 2; // 2 bytes (nombre d'entr√©es sur 2 bytes)
                case 0x30: // COINDEC
                case 0x31: // PAYINC
                case 0x35: // COININC
                case 0x36: // PAYDEC
                    return 2; // 2 bytes (slot + count)
                case 0x32: // OUTPUT1
                case 0x37: // OUTPUT2
                case 0x38: // OUTPUT3
                    // Arguments variables selon les donn√©es
                    return getVariableOutputArgCount(data, startIdx);
                case 0x33: // ANLOUT
                    return getAnalogOutputArgCount(data, startIdx);
                case 0x34: // CHAROUT
                    return getCharOutputArgCount(data, startIdx);
                default:
                    return 0; // Pas d'arguments ou commande inconnue
            }
        }
        
        function getVariableOutputArgCount(data, startIdx) {
            // Pour les commandes OUTPUT, le premier byte indique la taille
            if (startIdx < data.length) {
                return Math.ceil(data[startIdx] / 8) + 1; // Nombre de bytes + 1 pour la taille
            }
            return 0;
        }
        
        function getAnalogOutputArgCount(data, startIdx) {
            // Pour ANLOUT, arguments variables selon le nombre de canaux
            if (startIdx < data.length) {
                return data[startIdx] * 2 + 1; // 2 bytes par canal + 1 pour le nombre
            }
            return 0;
        }
        
        function getCharOutputArgCount(data, startIdx) {
            // Pour CHAROUT, chercher la fin de cha√Æne ou fin des donn√©es
            let count = 0;
            for (let i = startIdx; i < data.length; i++) {
                count++;
                if (data[i] === 0x00) break; // Fin de cha√Æne
            }
            return count;
        }
        
        function decodeSpecificCommand(command) {
            switch (command.cmdByte) {
                case 0xF0: // RESET
                    command.details = command.args.length > 0 && command.args[0] === 0xD9 ? 
                        'Argument correct (0xD9)' : 'Argument incorrect';
                    break;
                    
                case 0xF1: // SETADDR
                    command.details = command.args.length > 0 ? 
                        `Nouvelle adresse: 0x${command.args[0].toString(16).toUpperCase()}` : 'Pas d\'argument';
                    break;
                    
                case 0x20: // SWINP
                    if (command.args.length >= 2) {
                        command.details = `${command.args[0]} joueurs, ${command.args[1]} bytes par joueur`;
                    }
                    break;
                    
                case 0x21: // COININP
                    command.details = command.args.length > 0 ? `${command.args[0]} slots de monnaie` : '';
                    break;
                    
                case 0x22: // ANLINP
                    command.details = command.args.length > 0 ? `${command.args[0]} canaux analogiques` : '';
                    break;
                    
                case 0x23: // ROTINP
                    command.details = command.args.length > 0 ? `${command.args[0]} canaux rotatifs` : '';
                    break;
                    
                case 0x24: // KEYINP
                    command.details = command.args.length > 0 ? `${command.args[0]} codes clavier` : '';
                    break;
                    
                case 0x25: // SCRPOSINP
                    command.details = command.args.length > 0 ? `Canal ${command.args[0]} (position √©cran)` : '';
                    break;
                    
                case 0x26: // MISCSWINP
                    if (command.args.length >= 2) {
                        const miscInputs = (command.args[0] << 8) | command.args[1];
                        command.details = `${miscInputs} entr√©es diverses`;
                    }
                    break;
                    
                case 0x30: // COINDEC
                case 0x35: // COININC
                    if (command.args.length >= 2) {
                        command.details = `Slot ${command.args[0]}, count ${command.args[1]}`;
                    }
                    break;
                    
                case 0x31: // PAYINC
                case 0x36: // PAYDEC
                    if (command.args.length >= 2) {
                        command.details = `Paiement slot ${command.args[0]}, count ${command.args[1]}`;
                    }
                    break;
                    
                case 0x32: // OUTPUT1
                case 0x37: // OUTPUT2
                case 0x38: // OUTPUT3
                    if (command.args.length > 0) {
                        const outputBits = command.args[0];
                        const outputData = command.args.slice(1).map(b => 
                            `0x${b.toString(16).toUpperCase().padStart(2, '0')}`).join(' ');
                        command.details = `${outputBits} bits de sortie: ${outputData}`;
                    }
                    break;
                    
                case 0x33: // ANLOUT
                    if (command.args.length > 0) {
                        const channels = command.args[0];
                        const values = [];
                        for (let i = 1; i < command.args.length; i += 2) {
                            if (i + 1 < command.args.length) {
                                const value = (command.args[i] << 8) | command.args[i + 1];
                                values.push(value);
                            }
                        }
                        command.details = `${channels} canaux analogiques: ${values.join(', ')}`;
                    }
                    break;
                    
                case 0x34: // CHAROUT
                    if (command.args.length > 0) {
                        const text = String.fromCharCode(...command.args.filter(b => b !== 0x00));
                        command.details = `Texte: "${text}"`;
                    }
                    break;
            }
        }
        
        function decodeResponse(frame) {
            if (frame.unescapedBytes.length < 4) return;
            
            const statusByte = frame.unescapedBytes[3];
            frame.status = JVS.STATUS[statusByte] || `UNK_0x${statusByte.toString(16).toUpperCase()}`;
            frame.statusByte = statusByte;
            frame.sourceAddr = frame.destAddr; // Pour les r√©ponses, l'adresse de destination devient la source
            
            // Donn√©es de r√©ponse (sans sync, dest, length, status et checksum)
            const responseData = frame.unescapedBytes.slice(4, -1);
            frame.data = responseData;
            
            // Une r√©ponse JVS peut contenir plusieurs r√©sultats, chacun pr√©fix√© par un report byte
            frame.results = [];
            
            if (responseData.length > 0) {
                const prevCommand = findPreviousCommand(frame);
                console.log('Previous command found:', prevCommand);
                
                if (prevCommand && prevCommand.commands) {
                    console.log('Commands in previous frame:', prevCommand.commands.length, prevCommand.commands);
                } else {
                    console.log('No commands found in previous frame');
                }
                
                // Si on a une commande pr√©c√©dente avec plusieurs commandes, 
                // on doit parser selon les commandes attendues
                if (prevCommand && prevCommand.commands && prevCommand.commands.length > 1) {
                    console.log(`Parsing multi-command response for ${prevCommand.commands.length} commands`);
                    console.log('Response data:', responseData.map(b => `0x${b.toString(16).toUpperCase().padStart(2, '0')}`).join(' '));
                    
                    let i = 0;
                    
                    // Parser un r√©sultat pour chaque commande dans l'ordre
                    for (let cmdIdx = 0; cmdIdx < prevCommand.commands.length && i < responseData.length; cmdIdx++) {
                        const command = prevCommand.commands[cmdIdx];
                        console.log(`\nParsing result ${cmdIdx + 1} for command ${command.command} at position ${i}`);
                        console.log('Remaining data:', responseData.slice(i).map(b => `0x${b.toString(16).toUpperCase().padStart(2, '0')}`).join(' '));
                        
                        // V√©rifier s'il y a un report byte
                        if (i >= responseData.length) {
                            console.log('No more data available');
                            break;
                        }
                        
                        const reportByte = responseData[i];
                        console.log(`Report byte: 0x${reportByte.toString(16).toUpperCase()}`);
                        
                        const result = {
                            report: reportByte,
                            reportData: [],
                            details: '',
                            type: 'unknown'
                        };
                        
                        i++; // Passer au premier byte de donn√©es
                        
                        // Le REPORT_BYTE indique le succ√®s de cette commande sp√©cifique
                        // Si REPORT_BYTE = 0x01, il y a des donn√©es de r√©ponse
                        // Sinon, c'est une erreur et pas de donn√©es suppl√©mentaires
                        if (reportByte === 0x01) {
                            // D√©terminer la taille des donn√©es selon la commande
                            // L'adresse du device est celle de la commande pr√©c√©dente
                            const deviceAddr = prevCommand ? prevCommand.destAddr : null;
                            const dataSize = getExpectedResponseSize(command, responseData, i, deviceAddr);
                            console.log(`Expected data size: ${dataSize}`);
                            
                            // Extraire les donn√©es pour ce r√©sultat
                            for (let j = 0; j < dataSize && i < responseData.length; j++, i++) {
                                result.reportData.push(responseData[i]);
                            }
                        } else {
                            console.log(`Command failed with report byte 0x${reportByte.toString(16)}, no data`);
                        }
                        
                        console.log(`Extracted data:`, result.reportData.map(b => `0x${b.toString(16).toUpperCase().padStart(2, '0')}`).join(' '));
                        console.log(`New position: ${i}`);
                        
                        // Associer la commande m√™me en cas d'erreur  
                        result.associatedCommand = command.command;
                        result.associatedCmdByte = command.cmdByte;
                        
                        // D√©codage sp√©cifique du r√©sultat
                        decodeSpecificResult(result, statusByte, cmdIdx, command);
                        
                        frame.results.push(result);
                    }
                } else {
                    // Parsing g√©n√©rique pour commande unique
                    let i = 0;
                    
                    while (i < responseData.length) {
                        const reportByte = responseData[i];
                        const result = {
                            report: reportByte,
                            reportData: [],
                            details: '',
                            type: 'unknown'
                        };
                        
                        i++; // Passer au premier byte de donn√©es
                        
                        // D√©terminer la taille des donn√©es pour ce r√©sultat
                        const dataSize = getResponseDataSize(reportByte, responseData, i, frame);
                        
                        // Extraire les donn√©es pour ce r√©sultat
                        for (let j = 0; j < dataSize && i < responseData.length; j++, i++) {
                            result.reportData.push(responseData[i]);
                        }
                        
                        // Associer √† la commande si disponible
                        const associatedCommand = prevCommand && prevCommand.commands ? 
                                                prevCommand.commands[0] : null;
                        
                        // D√©codage sp√©cifique du r√©sultat
                        decodeSpecificResult(result, statusByte, frame.results.length, associatedCommand);
                        
                        frame.results.push(result);
                        
                        // Pour √©viter les boucles infinies
                        if (dataSize === 0) break;
                    }
                }
                
                // Pour compatibilit√© descendante, si un seul r√©sultat, copier dans les champs principaux
                if (frame.results.length === 1) {
                    frame.report = frame.results[0].report;
                    frame.reportData = frame.results[0].reportData;
                    frame.deviceName = frame.results[0].deviceName;
                    frame.featureData = frame.results[0].featureData;
                    frame.isFeatureCheck = frame.results[0].isFeatureCheck;
                    frame.inputData = frame.results[0].inputData;
                } else if (frame.results.length > 1) {
                    frame.isMultiResult = true;
                }
            }
            
            // Lier avec la commande pr√©c√©dente si possible
            linkToPreviousCommand(frame);
        }
        
        function getResponseDataSize(reportByte, data, startIdx, frame) {
            // D√©termine la taille des donn√©es pour un report byte donn√©
            
            // Report byte d'erreur ou status sp√©ciaux
            if (reportByte !== 0x01) {
                return 0; // Pas de donn√©es suppl√©mentaires pour les erreurs
            }
            
            // Pour un report byte normal (0x01), d√©terminer la taille selon le contexte
            // En utilisant la commande pr√©c√©dente si disponible
            const prevCommand = findPreviousCommand(frame);
            if (prevCommand && prevCommand.commands) {
                // Pour les multi-commandes, il faut associer les r√©sultats dans l'ordre
                // En utilisant l'index actuel du r√©sultat pour d√©terminer quelle commande correspond
                const resultIndex = frame.results ? frame.results.length : 0;
                if (resultIndex < prevCommand.commands.length) {
                    const cmd = prevCommand.commands[resultIndex];
                    const expectedSize = getExpectedResponseSize(cmd, data, startIdx);
                    if (expectedSize > 0) {
                        return expectedSize;
                    }
                }
            }
            
            // Heuristiques par d√©faut pour d√©terminer la taille
            if (startIdx >= data.length) return 0;
            
            // Si les donn√©es contiennent du texte ASCII, chercher la fin
            let textLen = 0;
            for (let i = startIdx; i < data.length; i++) {
                if (data[i] >= 0x20 && data[i] <= 0x7E) {
                    textLen++;
                } else if (data[i] === 0x00) {
                    return textLen + 1; // +1 pour inclure le null terminator
                } else {
                    break;
                }
            }
            
            // Si c'est potentiellement des donn√©es de feature check
            if (isFeatureCheckData(data, startIdx)) {
                return getFeatureCheckDataSize(data, startIdx);
            }
            
            // Par d√©faut, prendre toutes les donn√©es restantes
            return data.length - startIdx;
        }
        
        function getExpectedResponseSize(command, data, startIdx, deviceAddr) {
            console.log(`getExpectedResponseSize for ${command.command} (0x${command.cmdByte.toString(16)}) with args:`, command.args);
            
            // Trouver le n≈ìud JVS correspondant pour utiliser ses capacit√©s
            let deviceNode = null;
            if (deviceAddr) {
                deviceNode = jvsNodes.find(node => node.address === deviceAddr);
                if (deviceNode) {
                    console.log(`Found JVS node info for device 0x${deviceAddr.toString(16)}:`, deviceNode);
                }
            }
            
            switch (command.cmdByte) {
                case 0x10: // IOIDENT - nom du p√©riph√©rique
                    return findStringEndIndex(data, startIdx) - startIdx;
                case 0x11: // CMDREV - 1 byte
                case 0x12: // JVSREV - 1 byte  
                case 0x13: // COMMVER - 1 byte
                    return 1;
                case 0x14: // FEATCHK - donn√©es variables selon les fonctions
                    return getFeatureCheckDataSize(data, startIdx);
                case 0x20: // SWINP
                    if (command.args.length >= 2) {
                        const size = 1 + (command.args[0] * command.args[1]); // system byte + (joueurs * bytes par joueur)
                        console.log(`SWINP expected size: ${size} (1 system byte + ${command.args[0]} players √ó ${command.args[1]} bytes)`);
                        return size;
                    }
                    return 1; // Au minimum le system byte
                case 0x21: // COININP
                    // COININP retourne les donn√©es pour TOUS les slots support√©s (Feature Check)
                    // pas seulement ceux demand√©s dans la commande
                    
                    let coinSlots = command.args.length >= 1 ? command.args[0] : 2; // Par d√©faut selon commande
                    
                    // Utiliser les informations du Feature Check si disponibles
                    if (deviceNode && deviceNode.capabilities && deviceNode.capabilities.coinSlots) {
                        coinSlots = deviceNode.capabilities.coinSlots;
                        console.log(`Using Feature Check coin slots: ${coinSlots}`);
                    } else {
                        console.log(`No Feature Check info, using command arg: ${coinSlots}`);
                    }
                    
                    const size = coinSlots * 2; // slots * 2 bytes par slot
                    console.log(`COININP expected size: ${size} (${coinSlots} slots √ó 2 bytes)`);
                    return size;
                case 0x22: // ANLINP
                    if (command.args.length >= 1) {
                        const size = command.args[0] * 2; // canaux * 2 bytes par canal
                        console.log(`ANLINP expected size: ${size} (${command.args[0]} channels √ó 2 bytes)`);
                        return size;
                    }
                    return 0;
                case 0x23: // ROTINP
                    if (command.args.length >= 1) {
                        return command.args[0] * 2; // canaux * 2 bytes par canal
                    }
                    return 0;
                case 0x24: // KEYINP
                    if (command.args.length >= 1) {
                        return command.args[0]; // nombre de codes clavier
                    }
                    return 0;
                case 0x25: // SCRPOSINP
                    return 4; // X (2 bytes) + Y (2 bytes)
                case 0x26: // MISCSWINP
                    if (command.args.length >= 2) {
                        const miscInputs = (command.args[0] << 8) | command.args[1];
                        return Math.ceil(miscInputs / 8); // bits convertis en bytes
                    }
                    return 0;
                default:
                    console.log(`Unknown command 0x${command.cmdByte.toString(16)}, returning 0`);
                    return 0;
            }
        }
        
        function findStringEndIndex(data, startIdx) {
            for (let i = startIdx; i < data.length; i++) {
                if (data[i] === 0x00 || data[i] < 0x20 || data[i] > 0x7E) {
                    return i;
                }
            }
            return data.length;
        }
        
        function isFeatureCheckData(data, startIdx) {
            // V√©rifier si les donn√©es ressemblent √† une feature check
            if (startIdx + 3 >= data.length) return false;
            
            const funcCode = data[startIdx];
            return JVS.FUNC[funcCode] !== undefined;
        }
        
        function getFeatureCheckDataSize(data, startIdx) {
            let size = 0;
            let i = startIdx;
            
            while (i + 3 < data.length) {
                const funcCode = data[i];
                if (funcCode === 0x00) {
                    size += 1; // Inclure le terminator
                    break;
                }
                if (!JVS.FUNC[funcCode]) break;
                
                size += 4; // funcCode + 3 param√®tres
                i += 4;
            }
            
            return size;
        }
        
        function decodeSpecificResult(result, statusByte, resultIndex, associatedCommand) {
            if (statusByte === 0x01 && result.report === 0x01) {
                // R√©ponse normale
                
                // Associer le r√©sultat √† une commande sp√©cifique si disponible
                if (associatedCommand) {
                    result.associatedCommand = associatedCommand.command;
                    result.associatedCmdByte = associatedCommand.cmdByte;
                    
                    // D√©codage sp√©cialis√© selon la commande associ√©e
                    switch (associatedCommand.cmdByte) {
                        case 0x10: // IOIDENT
                            if (result.reportData.length > 0) {
                                const nameBytes = result.reportData.filter(b => b !== 0x00);
                                if (nameBytes.every(b => b >= 0x20 && b <= 0x7E)) {
                                    result.deviceName = String.fromCharCode(...nameBytes);
                                    result.type = 'device_name';
                                    result.details = `Nom: "${result.deviceName}"`;
                                }
                            }
                            break;
                            
                        case 0x11: // CMDREV
                        case 0x12: // JVSREV
                        case 0x13: // COMMVER
                            if (result.reportData.length === 1) {
                                result.type = 'version_data';
                                result.details = `Version: 0x${result.reportData[0].toString(16).toUpperCase()}`;
                            }
                            break;
                            
                        case 0x14: // FEATCHK
                            const possibleFeatureData = parseFeatureCheck(result.reportData);
                            if (possibleFeatureData) {
                                result.featureData = possibleFeatureData;
                                result.isFeatureCheck = true;
                                result.type = 'feature_check';
                                result.details = 'Donn√©es de capacit√©s JVS';
                            }
                            break;
                            
                        case 0x20: // SWINP
                            result.type = 'input_data';
                            
                            if (result.reportData.length > 0) {
                                const systemByte = result.reportData[0];
                                const players = associatedCommand.args[0] || 1;
                                const bytesPerPlayer = associatedCommand.args[1] || 1;
                                let switchDetails = [];
                                
                                // System byte info
                                const systemStatus = [];
                                if (systemByte & 0x01) systemStatus.push('Test');
                                if (systemByte & 0x02) systemStatus.push('Tilt1');
                                if (systemByte & 0x04) systemStatus.push('Tilt2');  
                                if (systemByte & 0x08) systemStatus.push('Tilt3');
                                
                                const systemInfo = systemStatus.length > 0 ? 
                                    `System:[${systemStatus.join(',')}]` : 'System:[-]';
                                
                                // Player data starts after system byte
                                const playerDataStart = 1;
                                for (let p = 0; p < players && playerDataStart + p * bytesPerPlayer < result.reportData.length; p++) {
                                    const playerStart = playerDataStart + p * bytesPerPlayer;
                                    const playerData = result.reportData.slice(playerStart, playerStart + bytesPerPlayer);
                                    const buttonStates = [];
                                    
                                    playerData.forEach((byte, byteIdx) => {
                                        for (let bit = 0; bit < 8; bit++) {
                                            if (byte & (1 << bit)) {
                                                const buttonNum = byteIdx * 8 + bit + 1;
                                                buttonStates.push(`B${buttonNum}`);
                                            }
                                        }
                                    });
                                    
                                    if (buttonStates.length > 0) {
                                        switchDetails.push(`J${p + 1}:[${buttonStates.join(',')}]`);
                                    } else {
                                        switchDetails.push(`J${p + 1}:[-]`);
                                    }
                                }
                                
                                const playerInfo = switchDetails.length > 0 ? switchDetails.join(' ') : '';
                                result.details = `${systemInfo} ${playerInfo}`.trim();
                            } else {
                                result.details = 'Pas de donn√©es SWINP';
                            }
                            break;
                            
                        case 0x21: // COININP
                            result.type = 'input_data';
                            const coinSlots = associatedCommand.args[0] || 1;
                            const coinData = [];
                            
                            for (let slot = 0; slot < coinSlots && slot * 2 < result.reportData.length; slot++) {
                                const idx = slot * 2;
                                if (idx + 1 < result.reportData.length) {
                                    const coinValue = (result.reportData[idx] << 8) | result.reportData[idx + 1];
                                    coinData.push(`Slot${slot + 1}:${coinValue}`);
                                }
                            }
                            result.details = `Monnaie: ${coinData.join(' ')}`;
                            break;
                            
                        case 0x22: // ANLINP
                            result.type = 'input_data';
                            const analogChannels = associatedCommand.args[0] || 1;
                            const analogData = [];
                            
                            for (let ch = 0; ch < analogChannels && ch * 2 < result.reportData.length; ch++) {
                                const idx = ch * 2;
                                if (idx + 1 < result.reportData.length) {
                                    const analogValue = (result.reportData[idx] << 8) | result.reportData[idx + 1];
                                    analogData.push(`CH${ch + 1}:${analogValue}`);
                                }
                            }
                            result.details = `Analogiques: ${analogData.join(' ')}`;
                            break;
                            
                        case 0x23: // ROTINP
                            result.type = 'input_data';
                            const rotaryChannels = associatedCommand.args[0] || 1;
                            const rotaryData = [];
                            
                            for (let ch = 0; ch < rotaryChannels && ch * 2 < result.reportData.length; ch++) {
                                const idx = ch * 2;
                                if (idx + 1 < result.reportData.length) {
                                    const rotaryValue = (result.reportData[idx] << 8) | result.reportData[idx + 1];
                                    rotaryData.push(`ROT${ch + 1}:${rotaryValue}`);
                                }
                            }
                            result.details = `Rotatifs: ${rotaryData.join(' ')}`;
                            break;
                            
                        case 0x24: // KEYINP
                            result.type = 'input_data';
                            const keyCount = associatedCommand.args[0] || result.reportData.length;
                            const keys = [];
                            
                            for (let i = 0; i < keyCount && i < result.reportData.length; i++) {
                                if (result.reportData[i] !== 0) {
                                    keys.push(`Key:0x${result.reportData[i].toString(16).toUpperCase()}`);
                                }
                            }
                            
                            result.details = keys.length > 0 ? 
                                `Clavier: ${keys.join(' ')}` : 'Clavier: aucune touche';
                            break;
                            
                        case 0x25: // SCRPOSINP
                            if (result.reportData.length >= 4) {
                                const x = (result.reportData[0] << 8) | result.reportData[1];
                                const y = (result.reportData[2] << 8) | result.reportData[3];
                                result.type = 'screen_pos';
                                result.details = `Position √©cran: X=${x}, Y=${y}`;
                            }
                            break;
                            
                        case 0x26: // MISCSWINP
                            result.type = 'input_data';
                            const miscInputBits = associatedCommand.args.length >= 2 ? 
                                (associatedCommand.args[0] << 8) | associatedCommand.args[1] : 16;
                            const miscBytes = Math.ceil(miscInputBits / 8);
                            
                            const miscStates = [];
                            for (let byteIdx = 0; byteIdx < miscBytes && byteIdx < result.reportData.length; byteIdx++) {
                                const byte = result.reportData[byteIdx];
                                for (let bit = 0; bit < 8; bit++) {
                                    const bitNum = byteIdx * 8 + bit;
                                    if (bitNum >= miscInputBits) break;
                                    
                                    if (byte & (1 << bit)) {
                                        miscStates.push(`M${bitNum + 1}`);
                                    }
                                }
                            }
                            
                            result.details = miscStates.length > 0 ? 
                                `Entr√©es diverses: [${miscStates.join(',')}]` : 
                                `Entr√©es diverses: [-]`;
                            break;
                            
                        default:
                            // Type de donn√©es g√©n√©rique
                            result.inputData = result.reportData.map(b => 
                                `0x${b.toString(16).toUpperCase().padStart(2, '0')}`).join(' ');
                            result.type = 'input_data';
                            result.details = `Donn√©es: ${result.inputData}`;
                    }
                } else {
                    // D√©codage g√©n√©rique sans commande associ√©e
                    
                    // D√©tection de nom de p√©riph√©rique (IOIDENT)
                    if (result.reportData.length > 10) {
                        const nameBytes = result.reportData.filter(b => b !== 0x00);
                        if (nameBytes.every(b => b >= 0x20 && b <= 0x7E)) {
                            result.deviceName = String.fromCharCode(...nameBytes);
                            result.type = 'device_name';
                            result.details = `Nom: "${result.deviceName}"`;
                        }
                    }
                    
                    // D√©tection de Feature Check (FEATCHK)
                    if (!result.deviceName && result.reportData.length >= 4) {
                        const possibleFeatureData = parseFeatureCheck(result.reportData);
                        if (possibleFeatureData) {
                            result.featureData = possibleFeatureData;
                            result.isFeatureCheck = true;
                            result.type = 'feature_check';
                            result.details = 'Donn√©es de capacit√©s JVS';
                        } else {
                            // Donn√©es d'entr√©e (boutons, analog, etc.)
                            result.inputData = result.reportData.map(b => 
                                `0x${b.toString(16).toUpperCase().padStart(2, '0')}`).join(' ');
                            result.type = 'input_data';
                            result.details = `Donn√©es: ${result.inputData}`;
                        }
                    }
                    
                    // Donn√©es courtes (versions, etc.)
                    else if (!result.deviceName && !result.featureData && result.reportData.length > 0) {
                        if (result.reportData.length === 1) {
                            result.type = 'version_data';
                            result.details = `Version: 0x${result.reportData[0].toString(16).toUpperCase()}`;
                        } else {
                            result.inputData = result.reportData.map(b => 
                                `0x${b.toString(16).toUpperCase().padStart(2, '0')}`).join(' ');
                            result.type = 'data';
                            result.details = `Donn√©es: ${result.inputData}`;
                        }
                    }
                }
            } else {
                // R√©ponse d'erreur ou status sp√©cial
                result.type = 'status';
                result.details = `Status: 0x${result.report.toString(16).toUpperCase()}`;
            }
        }
        
        function parseFeatureCheck(data) {
            const features = {
                players: 0,
                buttons: 0,
                coinSlots: 0,
                analogChannels: 0,
                analogBits: 0,
                rotaryChannels: 0,
                hasKeycode: false,
                hasScreenPos: false,
                screenPosXBits: 0,
                screenPosYBits: 0,
                miscDigitalInputs: 0,
                digitalOutputs: 0,
                analogOutputChannels: 0,
                cardSystemSlots: 0,
                medalHopperChannels: 0,
                hasCharDisplay: false,
                charDisplayWidth: 0,
                charDisplayHeight: 0,
                charDisplayType: 0,
                hasBackup: false,
                rawFeatureData: []
            };
            
            let isFeatureData = false;
            let i = 0;
            
            while (i + 3 < data.length) {
                const funcCode = data[i];
                const param1 = data[i + 1];
                const param2 = data[i + 2];
                const param3 = data[i + 3];
                
                // Terminator
                if (funcCode === 0x00) break;
                
                // V√©rifier si c'est un code de fonction valide
                if (!JVS.FUNC[funcCode]) {
                    // Pas une feature check valide
                    if (!isFeatureData) return null;
                    break;
                }
                
                isFeatureData = true;
                features.rawFeatureData.push({ funcCode, param1, param2, param3 });
                
                switch (funcCode) {
                    case 0x01: // INPUT_DIGITAL
                        features.players = param1 & 0x0F;
                        features.buttons = param2;
                        break;
                    case 0x02: // INPUT_COIN
                        features.coinSlots = param1 & 0x0F;
                        break;
                    case 0x03: // INPUT_ANALOG
                        features.analogChannels = param1 & 0x0F;
                        features.analogBits = param2;
                        break;
                    case 0x04: // INPUT_ROTARY
                        features.rotaryChannels = param1 & 0x0F;
                        break;
                    case 0x05: // INPUT_KEYCODE
                        features.hasKeycode = true;
                        break;
                    case 0x06: // INPUT_SCREEN_POS
                        features.hasScreenPos = true;
                        features.screenPosXBits = param1;
                        features.screenPosYBits = param2;
                        break;
                    case 0x07: // INPUT_MISC_DIGITAL
                        features.miscDigitalInputs = param1;
                        break;
                    case 0x10: // OUTPUT_CARD
                        features.cardSystemSlots = param1;
                        break;
                    case 0x11: // OUTPUT_HOPPER
                        features.medalHopperChannels = param1;
                        break;
                    case 0x12: // OUTPUT_DIGITAL
                        features.digitalOutputs = param1;
                        break;
                    case 0x13: // OUTPUT_ANALOG
                        features.analogOutputChannels = param1 & 0x0F;
                        break;
                    case 0x14: // OUTPUT_CHAR
                        features.hasCharDisplay = true;
                        features.charDisplayWidth = param1;
                        features.charDisplayHeight = param2;
                        features.charDisplayType = param3;
                        break;
                    case 0x15: // OUTPUT_BACKUP
                        features.hasBackup = true;
                        break;
                }
                
                i += 4;
            }
            
            return isFeatureData ? features : null;
        }
        
        function findPreviousCommand(frame) {
            // Pour une r√©ponse avec destAddr 0x00, on cherche la derni√®re commande vers n'importe quel device
            // Pour une r√©ponse avec un destAddr sp√©cifique, on cherche une commande vers ce device
            const targetAddr = frame.destAddr === 0x00 ? null : frame.destAddr;
            
            console.log(`Looking for command with destAddr matching response from ${frame.destAddr}`);
            
            // Trouver la commande pr√©c√©dente dans les trames
            for (let i = frames.length - 1; i >= 0; i--) {
                const prevFrame = frames[i];
                console.log(`Checking frame ${i}: type=${prevFrame.type}, destAddr=0x${prevFrame.destAddr.toString(16)}`);
                
                if (prevFrame.type === 'command') {
                    // Pour les r√©ponses du host (destAddr = 0x00), prendre la derni√®re commande
                    if (frame.destAddr === 0x00) {
                        console.log('Found matching command for host response');
                        return prevFrame;
                    }
                    // Pour les autres r√©ponses, matcher l'adresse
                    else if (prevFrame.destAddr === frame.destAddr) {
                        console.log('Found matching command by address');
                        return prevFrame;
                    }
                }
            }
            console.log('No matching command found');
            return null;
        }
        
        function linkToPreviousCommand(frame) {
            // Trouver la commande pr√©c√©dente dans les trames
            const prevFrame = findPreviousCommand(frame);
            if (prevFrame) {
                frame.previousCommand = prevFrame.cmdByte;
                frame.previousCommandArgs = prevFrame.args;
                frame.previousCommands = prevFrame.commands; // Support multi-commandes
            }
        }
        
        function processFrameForNodeInfo(frame) {
            if (frame.type !== 'response' || !frame.data || frame.data.length === 0) return;
            
            // R√©ponse √† SETADDR - cr√©er ou mettre √† jour un n≈ìud
            if (frame.previousCommand === 0xF1) {  // CMD_SETADDR
                const nodeAddr = frame.previousCommandArgs && frame.previousCommandArgs[0];
                if (nodeAddr && frame.report === 0x01) {
                    let node = jvsNodes.find(n => n.address === nodeAddr);
                    if (!node) {
                        node = {
                            address: nodeAddr,
                            name: '',
                            cmdVersion: null,
                            jvsVersion: null,
                            commVersion: null,
                            capabilities: {}
                        };
                        jvsNodes.push(node);
                    }
                }
            }
            
            // R√©ponse √† IOIDENT - nom du n≈ìud  
            else if (frame.previousCommand === 0x10 && frame.deviceName) {
                const node = jvsNodes.find(n => n.address === frame.sourceAddr);
                if (node) {
                    node.name = frame.deviceName;
                }
            }
            
            // R√©ponse √† FEATCHK - capacit√©s du n≈ìud
            else if (frame.previousCommand === 0x14) {
                const node = jvsNodes.find(n => n.address === frame.sourceAddr);
                if (node && frame.featureData) {
                    node.capabilities = frame.featureData;
                }
            }
        }
        
        function displayFrames() {
            const container = document.getElementById('framesContainer');
            container.style.display = 'block';
            
            // Cr√©er les paires requ√™te/r√©ponse
            createExchanges();
            
            // Initialiser la navigation
            currentExchangeIndex = 0;
            updateNavigationState();
            
            // Afficher le premier √©change
            if (exchanges.length > 0) {
                displayExchange(0);
            }
            
            // Afficher les informations des n≈ìuds JVS si disponibles
            displayNodeInfo();
        }
        
        function createExchanges() {
            exchanges = [];
            let currentCommand = null;
            
            frames.forEach(frame => {
                if (frame.type === 'command') {
                    // Nouveau √©change : commande
                    currentCommand = frame;
                } else if (frame.type === 'response' && currentCommand) {
                    // R√©ponse √† la commande pr√©c√©dente
                    exchanges.push({
                        request: currentCommand,
                        response: frame,
                        exchangeNumber: exchanges.length + 1
                    });
                    currentCommand = null; // Reset pour le prochain √©change
                }
            });
            
            console.log(`${exchanges.length} √©changes cr√©√©s`);
        }
        
        function displayExchange(index) {
            if (index < 0 || index >= exchanges.length) return;
            
            const exchange = exchanges[index];
            const display = document.getElementById('exchangeDisplay');
            
            display.innerHTML = `
                <div class="step-indicator">
                    √âchange ${exchange.exchangeNumber} / ${exchanges.length}
                </div>
                
                <div class="exchange-title">
                    ${getExchangeTitle(exchange)}
                </div>
                
                <div class="request-response-pair">
                    <div class="request-panel">
                        <div class="panel-title request-title">
                            üì§ REQU√äTE (Host ‚Üí Device)
                        </div>
                        ${generateFrameContent(exchange.request)}
                    </div>
                    
                    <div class="response-panel">
                        <div class="panel-title response-title">
                            üì• R√âPONSE (Device ‚Üí Host)
                        </div>
                        ${generateFrameContent(exchange.response)}
                    </div>
                </div>
            `;
            
            currentExchangeIndex = index;
            updateNavigationState();
        }
        
        function getExchangeTitle(exchange) {
            const request = exchange.request;
            const status = exchange.response.status || 'Status inconnu';
            
            // Descriptions sp√©cifiques par commande
            const descriptions = {
                'RESET': 'üîÑ R√©initialisation du syst√®me JVS',
                'SETADDR': 'üéØ Attribution d\'adresse au p√©riph√©rique',
                'IOIDENT': 'üìù Identification du p√©riph√©rique',
                'CMDREV': 'üìä Version des commandes support√©es',
                'JVSREV': 'üìä Version du protocole JVS',
                'COMMVER': 'üìä Version de communication',
                'FEATCHK': 'üîç V√©rification des capacit√©s',
                'SWINP': 'üéÆ Lecture des entr√©es digitales',
                'COININP': 'ü™ô Lecture des entr√©es monnaie',
                'ANLINP': 'üìà Lecture des entr√©es analogiques',
                'ROTINP': 'üîÑ Lecture des entr√©es rotatives',
                'KEYINP': '‚å®Ô∏è Lecture des entr√©es clavier',
                'SCRPOSINP': 'üñ±Ô∏è Lecture position √©cran',
                'MISCSWINP': 'üìä Lecture entr√©es diverses'
            };
            
            // Gestion des multi-commandes
            if (request.isMultiCommand && request.commands && request.commands.length > 1) {
                const cmdNames = request.commands.map(cmd => cmd.command).join(' + ');
                return `üîó Multi-commandes: ${cmdNames} - ${status}`;
            } else {
                const cmd = request.command || 'Commande inconnue';
                return descriptions[cmd] || `üì° ${cmd} - ${status}`;
            }
        }
        
        function generateFrameContent(frame) {
            let content = `
                <div class="raw-data" id="raw-${frame.type}-${frame.lineNumber}" style="margin-bottom: 10px;">${formatHexStringWithIds(frame.rawHex, frame.lineNumber)}</div>
                ${generateDecodedInfo(frame)}
            `;
            return content;
        }
        
        function formatHexStringWithIds(hexString, frameId) {
            let result = '';
            for (let i = 0; i < hexString.length; i += 2) {
                const byte = hexString.substr(i, 2);
                const byteIndex = i / 2;
                result += `<span class="byte" id="byte-${frameId}-${byteIndex}" data-byte-index="${byteIndex}">${byte}</span> `;
            }
            return result.trim();
        }
        
        function highlightBytes(frameId, startIndex, length) {
            // Effacer les highlights pr√©c√©dents
            clearHighlights(frameId);
            
            // Ajouter les nouveaux highlights
            for (let i = startIndex; i < startIndex + length; i++) {
                const byteElement = document.getElementById(`byte-${frameId}-${i}`);
                if (byteElement) {
                    byteElement.classList.add('byte-highlight');
                }
            }
        }
        
        function clearHighlights(frameId) {
            const rawDataElement = document.getElementById(`raw-response-${frameId}`);
            if (rawDataElement) {
                const highlightedBytes = rawDataElement.querySelectorAll('.byte-highlight');
                highlightedBytes.forEach(byte => byte.classList.remove('byte-highlight'));
            } else {
                // Fallback: supprimer tous les highlights visibles
                const allHighlighted = document.querySelectorAll('.byte-highlight');
                allHighlighted.forEach(byte => byte.classList.remove('byte-highlight'));
            }
        }
        
        function navigateExchange(direction) {
            const newIndex = currentExchangeIndex + direction;
            if (newIndex >= 0 && newIndex < exchanges.length) {
                displayExchange(newIndex);
            }
        }
        
        function goToExchange(index) {
            if (index >= 0 && index < exchanges.length) {
                displayExchange(index);
            }
        }
        
        function updateNavigationState() {
            const firstBtn = document.getElementById('firstBtn');
            const prevBtn = document.getElementById('prevBtn');
            const nextBtn = document.getElementById('nextBtn');
            const lastBtn = document.getElementById('lastBtn');
            const exchangeInfo = document.getElementById('exchangeInfo');
            
            if (firstBtn) firstBtn.disabled = currentExchangeIndex === 0;
            if (prevBtn) prevBtn.disabled = currentExchangeIndex === 0;
            if (nextBtn) nextBtn.disabled = currentExchangeIndex === exchanges.length - 1;
            if (lastBtn) lastBtn.disabled = currentExchangeIndex === exchanges.length - 1;
            
            if (exchangeInfo) {
                exchangeInfo.textContent = `√âchange ${currentExchangeIndex + 1} / ${exchanges.length}`;
            }
        }
        
        function toggleAutoPlay() {
            const playPauseBtn = document.getElementById('playPauseBtn');
            
            if (autoPlay) {
                // Arr√™ter la lecture automatique
                autoPlay = false;
                if (autoPlayInterval) {
                    clearInterval(autoPlayInterval);
                    autoPlayInterval = null;
                }
                if (playPauseBtn) {
                    playPauseBtn.innerHTML = '‚ñ∂Ô∏è Lecture auto';
                    playPauseBtn.style.backgroundColor = '#0e639c';
                }
            } else {
                // D√©marrer la lecture automatique
                autoPlay = true;
                if (playPauseBtn) {
                    playPauseBtn.innerHTML = '‚è∏Ô∏è Pause';
                    playPauseBtn.style.backgroundColor = '#d32f2f';
                }
                
                autoPlayInterval = setInterval(() => {
                    if (currentExchangeIndex < exchanges.length - 1) {
                        navigateExchange(1);
                    } else {
                        // Fin de la capture, recommencer au d√©but
                        goToExchange(0);
                    }
                }, 2000); // 2 secondes entre chaque √©change
            }
        }
        
        function handleKeyNavigation(event) {
            if (exchanges.length === 0) return;
            
            // √âviter la navigation si l'utilisateur tape dans un champ
            if (event.target.tagName === 'INPUT') return;
            
            switch (event.key) {
                case 'ArrowLeft':
                    event.preventDefault();
                    navigateExchange(-1);
                    break;
                case 'ArrowRight':
                    event.preventDefault();
                    navigateExchange(1);
                    break;
                case 'Home':
                    event.preventDefault();
                    goToExchange(0);
                    break;
                case 'End':
                    event.preventDefault();
                    goToExchange(exchanges.length - 1);
                    break;
                case ' ': // Espace
                    event.preventDefault();
                    toggleAutoPlay();
                    break;
            }
        }
        
        function displayNodeInfo() {
            const container = document.getElementById('nodeInfoContainer');
            const nodesList = document.getElementById('nodesList');
            
            if (jvsNodes.length === 0) {
                container.style.display = 'none';
                return;
            }
            
            container.style.display = 'block';
            nodesList.innerHTML = '';
            
            jvsNodes.forEach(node => {
                const nodeCard = document.createElement('div');
                nodeCard.className = 'node-card';
                
                const capabilities = node.capabilities || {};
                
                nodeCard.innerHTML = `
                    <div class="node-header">
                        <span class="node-name">${node.name || 'N≈ìud JVS inconnu'}</span>
                        <span class="node-address">Adresse: 0x${node.address.toString(16).toUpperCase().padStart(2, '0')}</span>
                    </div>
                    
                    <div class="capabilities-grid">
                        ${generateInputCapabilities(capabilities)}
                        ${generateOutputCapabilities(capabilities)}
                        ${generateVersionInfo(node)}
                    </div>
                    
                    ${capabilities.rawFeatureData ? generateRawFeatureData(capabilities.rawFeatureData) : ''}
                `;
                
                nodesList.appendChild(nodeCard);
            });
        }
        
        function generateInputCapabilities(capabilities) {
            let html = '<div class="capability-group">';
            html += '<div class="capability-title">Entr√©es</div>';
            
            if (capabilities.players > 0) {
                html += `<div class="capability-item">Joueurs: <span class="capability-value">${capabilities.players}</span></div>`;
                html += `<div class="capability-item">Boutons par joueur: <span class="capability-value">${capabilities.buttons || 'N/A'}</span></div>`;
            }
            
            if (capabilities.coinSlots > 0) {
                html += `<div class="capability-item">Slots monnaie: <span class="capability-value">${capabilities.coinSlots}</span></div>`;
            }
            
            if (capabilities.analogChannels > 0) {
                html += `<div class="capability-item">Canaux analogiques: <span class="capability-value">${capabilities.analogChannels}</span></div>`;
                if (capabilities.analogBits) {
                    html += `<div class="capability-item">R√©solution: <span class="capability-value">${capabilities.analogBits} bits</span></div>`;
                }
            }
            
            if (capabilities.rotaryChannels > 0) {
                html += `<div class="capability-item">Encodeurs rotatifs: <span class="capability-value">${capabilities.rotaryChannels}</span></div>`;
            }
            
            if (capabilities.hasKeycode) {
                html += `<div class="capability-item">Support clavier: <span class="capability-value">Oui</span></div>`;
            }
            
            if (capabilities.hasScreenPos) {
                html += `<div class="capability-item">Position √©cran: <span class="capability-value">Oui</span></div>`;
                if (capabilities.screenPosXBits && capabilities.screenPosYBits) {
                    html += `<div class="capability-item">R√©solution: <span class="capability-value">${capabilities.screenPosXBits}x${capabilities.screenPosYBits} bits</span></div>`;
                }
            }
            
            if (capabilities.miscDigitalInputs > 0) {
                html += `<div class="capability-item">Entr√©es diverses: <span class="capability-value">${capabilities.miscDigitalInputs} bits</span></div>`;
            }
            
            if (html === '<div class="capability-group"><div class="capability-title">Entr√©es</div>') {
                html += '<div class="capability-item">Aucune entr√©e d√©tect√©e</div>';
            }
            
            html += '</div>';
            return html;
        }
        
        function generateOutputCapabilities(capabilities) {
            let html = '<div class="capability-group">';
            html += '<div class="capability-title">Sorties</div>';
            
            if (capabilities.digitalOutputs > 0) {
                html += `<div class="capability-item">Sorties digitales: <span class="capability-value">${capabilities.digitalOutputs}</span></div>`;
            }
            
            if (capabilities.analogOutputChannels > 0) {
                html += `<div class="capability-item">Sorties analogiques: <span class="capability-value">${capabilities.analogOutputChannels}</span></div>`;
            }
            
            if (capabilities.cardSystemSlots > 0) {
                html += `<div class="capability-item">Syst√®me de cartes: <span class="capability-value">${capabilities.cardSystemSlots} slots</span></div>`;
            }
            
            if (capabilities.medalHopperChannels > 0) {
                html += `<div class="capability-item">Distributeurs: <span class="capability-value">${capabilities.medalHopperChannels}</span></div>`;
            }
            
            if (capabilities.hasCharDisplay) {
                html += `<div class="capability-item">Affichage caract√®res: <span class="capability-value">Oui</span></div>`;
                if (capabilities.charDisplayWidth && capabilities.charDisplayHeight) {
                    html += `<div class="capability-item">Taille: <span class="capability-value">${capabilities.charDisplayWidth}x${capabilities.charDisplayHeight}</span></div>`;
                }
            }
            
            if (capabilities.hasBackup) {
                html += `<div class="capability-item">Sauvegarde: <span class="capability-value">Oui</span></div>`;
            }
            
            if (html === '<div class="capability-group"><div class="capability-title">Sorties</div>') {
                html += '<div class="capability-item">Aucune sortie d√©tect√©e</div>';
            }
            
            html += '</div>';
            return html;
        }
        
        function generateVersionInfo(node) {
            let html = '<div class="capability-group">';
            html += '<div class="capability-title">Versions</div>';
            
            if (node.cmdVersion !== null) {
                html += `<div class="capability-item">Commandes: <span class="capability-value">0x${node.cmdVersion.toString(16).toUpperCase()}</span></div>`;
            }
            
            if (node.jvsVersion !== null) {
                html += `<div class="capability-item">JVS: <span class="capability-value">0x${node.jvsVersion.toString(16).toUpperCase()}</span></div>`;
            }
            
            if (node.commVersion !== null) {
                html += `<div class="capability-item">Communication: <span class="capability-value">0x${node.commVersion.toString(16).toUpperCase()}</span></div>`;
            }
            
            if (html === '<div class="capability-group"><div class="capability-title">Versions</div>') {
                html += '<div class="capability-item">Informations non disponibles</div>';
            }
            
            html += '</div>';
            return html;
        }
        
        function generateRawFeatureData(rawData) {
            let html = '<div class="feature-data">';
            html += '<strong>Donn√©es brutes de Feature Check:</strong><br>';
            
            rawData.forEach(block => {
                const funcInfo = JVS.FUNC[block.funcCode] || { name: 'UNKNOWN', desc: 'Fonction inconnue' };
                html += `<div class="feature-block">`;
                html += `<span class="func-code">0x${block.funcCode.toString(16).toUpperCase().padStart(2, '0')} (${funcInfo.name})</span>: `;
                html += `<span class="func-params">[${block.param1.toString(16).toUpperCase()}, ${block.param2.toString(16).toUpperCase()}, ${block.param3.toString(16).toUpperCase()}]</span>`;
                html += `<br><em>${funcInfo.desc}</em>`;
                html += `</div>`;
            });
            
            html += '</div>';
            return html;
        }
        
        function generateFeatureCheckInfo(featureData) {
            let info = '<div class="field" style="margin-top: 10px;"><div style="font-weight: bold; color: #ffd700; margin-bottom: 8px;">üìã Feature Check - Capacit√©s d√©tect√©es:</div>';
            
            if (featureData.players > 0) {
                info += `<div style="margin: 4px 0; color: #e0e0e0;">‚Ä¢ <span style="color: #4fc3f7;">Joueurs:</span> ${featureData.players} (${featureData.buttons} boutons chacun)</div>`;
            }
            
            if (featureData.coinSlots > 0) {
                info += `<div style="margin: 4px 0; color: #e0e0e0;">‚Ä¢ <span style="color: #4fc3f7;">Monnaie:</span> ${featureData.coinSlots} slots</div>`;
            }
            
            if (featureData.analogChannels > 0) {
                info += `<div style="margin: 4px 0; color: #e0e0e0;">‚Ä¢ <span style="color: #4fc3f7;">Analogique:</span> ${featureData.analogChannels} canaux (${featureData.analogBits} bits)</div>`;
            }
            
            if (featureData.rotaryChannels > 0) {
                info += `<div style="margin: 4px 0; color: #e0e0e0;">‚Ä¢ <span style="color: #4fc3f7;">Rotatif:</span> ${featureData.rotaryChannels} encodeurs</div>`;
            }
            
            if (featureData.hasKeycode) {
                info += `<div style="margin: 4px 0; color: #e0e0e0;">‚Ä¢ <span style="color: #4fc3f7;">Clavier:</span> Support√©</div>`;
            }
            
            if (featureData.hasScreenPos) {
                info += `<div style="margin: 4px 0; color: #e0e0e0;">‚Ä¢ <span style="color: #4fc3f7;">Position √©cran:</span> ${featureData.screenPosXBits}√ó${featureData.screenPosYBits} bits</div>`;
            }
            
            if (featureData.miscDigitalInputs > 0) {
                info += `<div style="margin: 4px 0; color: #e0e0e0;">‚Ä¢ <span style="color: #4fc3f7;">Entr√©es diverses:</span> ${featureData.miscDigitalInputs} bits</div>`;
            }
            
            if (featureData.digitalOutputs > 0) {
                info += `<div style="margin: 4px 0; color: #e0e0e0;">‚Ä¢ <span style="color: #ffb74d;">Sorties digitales:</span> ${featureData.digitalOutputs}</div>`;
            }
            
            if (featureData.analogOutputChannels > 0) {
                info += `<div style="margin: 4px 0; color: #e0e0e0;">‚Ä¢ <span style="color: #ffb74d;">Sorties analogiques:</span> ${featureData.analogOutputChannels} canaux</div>`;
            }
            
            if (featureData.hasCharDisplay) {
                info += `<div style="margin: 4px 0; color: #e0e0e0;">‚Ä¢ <span style="color: #ffb74d;">Affichage:</span> ${featureData.charDisplayWidth}√ó${featureData.charDisplayHeight} caract√®res</div>`;
            }
            
            if (featureData.cardSystemSlots > 0) {
                info += `<div style="margin: 4px 0; color: #e0e0e0;">‚Ä¢ <span style="color: #ffb74d;">Syst√®me cartes:</span> ${featureData.cardSystemSlots} slots</div>`;
            }
            
            if (featureData.medalHopperChannels > 0) {
                info += `<div style="margin: 4px 0; color: #e0e0e0;">‚Ä¢ <span style="color: #ffb74d;">Distributeurs:</span> ${featureData.medalHopperChannels} canaux</div>`;
            }
            
            if (featureData.hasBackup) {
                info += `<div style="margin: 4px 0; color: #e0e0e0;">‚Ä¢ <span style="color: #ffb74d;">Sauvegarde:</span> Support√©e</div>`;
            }
            
            // Affichage des donn√©es brutes
            if (featureData.rawFeatureData && featureData.rawFeatureData.length > 0) {
                info += `<div style="margin-top: 8px; font-size: 0.9em; color: #9cdcfe;">Blocs fonctions:</div>`;
                featureData.rawFeatureData.forEach(block => {
                    const funcInfo = JVS.FUNC[block.funcCode] || { name: 'UNK', desc: 'Inconnu' };
                    info += `<div style="margin: 2px 0; font-family: monospace; font-size: 0.8em; color: #ce9178;">`;
                    info += `[0x${block.funcCode.toString(16).toUpperCase().padStart(2, '0')} ${block.param1.toString(16).toUpperCase().padStart(2, '0')} ${block.param2.toString(16).toUpperCase().padStart(2, '0')} ${block.param3.toString(16).toUpperCase().padStart(2, '0')}] ${funcInfo.name}`;
                    info += `</div>`;
                });
            }
            
            info += '</div>';
            return info;
        }
        
        function formatHexString(hexString) {
            let result = '';
            for (let i = 0; i < hexString.length; i += 2) {
                const byte = hexString.substr(i, 2);
                // Highlight escape sequences
                if (byte === 'D0' && i + 2 < hexString.length) {
                    const nextByte = hexString.substr(i + 2, 2);
                    if (nextByte === 'DF' || nextByte === 'CF') {
                        result += `<span class="escape-highlight">${byte}${nextByte}</span> `;
                        i += 2;
                        continue;
                    }
                }
                result += byte + ' ';
            }
            return result.trim();
        }
        
        function generateDecodedInfo(frame) {
            let info = '<div class="decoded-info">';
            
            info += `<div class="field"><span class="field-name">Sync:</span> <span class="field-value">0x${frame.sync.toString(16).toUpperCase()}</span></div>`;
            info += `<div class="field"><span class="field-name">Dest. Addr:</span> <span class="field-value">0x${frame.destAddr.toString(16).toUpperCase()}</span></div>`;
            info += `<div class="field"><span class="field-name">Longueur:</span> <span class="field-value">${frame.length}</span></div>`;
            
            if (frame.type === 'command') {
                // Gestion des multi-commandes
                if (frame.isMultiCommand && frame.commands) {
                    info += `<div class="field"><span class="field-name">Type:</span> <span class="field-value">Multi-commandes (${frame.commands.length})</span></div>`;
                    info += '<div class="multi-commands-container">';
                    
                    frame.commands.forEach((cmd, index) => {
                        info += `<div class="command-block" style="margin: 10px 0; padding: 8px; background-color: #2d2d2d; border-left: 3px solid #569cd6;">`;
                        info += `<div style="color: #569cd6; font-weight: bold;">Commande ${index + 1}: ${cmd.command} (0x${cmd.cmdByte.toString(16).toUpperCase()})</div>`;
                        
                        if (cmd.args.length > 0) {
                            info += `<div style="margin: 4px 0;"><span style="color: #9cdcfe;">Arguments:</span> ${cmd.args.map(b => '0x' + b.toString(16).toUpperCase().padStart(2, '0')).join(' ')}</div>`;
                        }
                        
                        if (cmd.details) {
                            info += `<div style="margin: 4px 0;"><span style="color: #9cdcfe;">D√©tails:</span> ${cmd.details}</div>`;
                        }
                        
                        info += '</div>';
                    });
                    
                    info += '</div>';
                } else {
                    // Commande simple (compatibilit√© descendante)
                    info += `<div class="field"><span class="field-name">Commande:</span> <span class="field-value">${frame.command} (0x${frame.cmdByte.toString(16).toUpperCase()})</span></div>`;
                    if (frame.args.length > 0) {
                        info += `<div class="field"><span class="field-name">Arguments:</span> <span class="field-value">${frame.args.map(b => '0x' + b.toString(16).toUpperCase().padStart(2, '0')).join(' ')}</span></div>`;
                    }
                    if (frame.details) {
                        info += `<div class="field"><span class="field-name">D√©tails:</span> <span class="field-value">${frame.details}</span></div>`;
                    }
                }
            } else {
                // Gestion des r√©ponses avec multi-r√©sultats
                info += `<div class="field"><span class="field-name">Status:</span> <span class="field-value">${frame.status} (0x${frame.statusByte.toString(16).toUpperCase()})</span></div>`;
                
                if (frame.isMultiResult && frame.results) {
                    info += `<div class="field"><span class="field-name">Type:</span> <span class="field-value">Multi-r√©sultats (${frame.results.length})</span></div>`;
                    info += '<div class="multi-results-container">';
                    
                    frame.results.forEach((result, index) => {
                        // Calculer la position des bytes dans la trame pour le highlight
                        const responseStartByte = 4; // Apr√®s sync, dest, length, status
                        let bytePosition = responseStartByte;
                        
                        // Calculer l'offset de ce r√©sultat
                        for (let i = 0; i < index; i++) {
                            bytePosition += 1; // Report byte
                            if (frame.results[i].report === 0x01) {
                                bytePosition += frame.results[i].reportData.length; // Donn√©es
                            }
                        }
                        
                        const resultStartByte = bytePosition;
                        const resultLength = 1 + (result.report === 0x01 ? result.reportData.length : 0); // Report + donn√©es
                        
                        info += `<div class="result-block" 
                                    style="margin: 10px 0; padding: 8px; background-color: #2d2d2d; border-left: 3px solid #4caf50;"
                                    onmouseenter="highlightBytes(${frame.lineNumber}, ${resultStartByte}, ${resultLength})"
                                    onmouseleave="clearHighlights(${frame.lineNumber})">`;
                        
                        // Utiliser le nom de la commande associ√©e plut√¥t que le num√©ro
                        let title = result.associatedCommand ? 
                                   `R√©sultat ${result.associatedCommand}` : 
                                   `R√©sultat ${index + 1}`;
                        title += ` ‚Üí Report 0x${result.report.toString(16).toUpperCase()}`;
                        
                        info += `<div style="color: #4caf50; font-weight: bold;">${title}</div>`;
                        
                        if (result.details) {
                            info += `<div style="margin: 4px 0;"><span style="color: #9cdcfe;">D√©tails:</span> ${result.details}</div>`;
                        }
                        
                        if (result.deviceName) {
                            info += `<div style="margin: 4px 0;"><span style="color: #9cdcfe;">Nom device:</span> ${result.deviceName}</div>`;
                        }
                        
                        if (result.isFeatureCheck && result.featureData) {
                            info += generateFeatureCheckInfo(result.featureData);
                        }
                        
                        if (result.inputData && !result.isFeatureCheck) {
                            info += `<div style="margin: 4px 0;"><span style="color: #9cdcfe;">Donn√©es:</span> ${result.inputData}</div>`;
                        }
                        
                        // Afficher les donn√©es brutes si utile
                        if (result.reportData && result.reportData.length > 0 && !result.isFeatureCheck) {
                            const rawHex = result.reportData.map(b => `0x${b.toString(16).toUpperCase().padStart(2, '0')}`).join(' ');
                            info += `<div style="margin: 4px 0; font-size: 0.85em; color: #808080;"><span style="color: #9cdcfe;">Raw:</span> ${rawHex}</div>`;
                        }
                        
                        info += '</div>';
                    });
                    
                    info += '</div>';
                } else {
                    // R√©ponse simple (compatibilit√© descendante)
                    if (frame.report !== undefined) {
                        info += `<div class="field"><span class="field-name">Report:</span> <span class="field-value">0x${frame.report.toString(16).toUpperCase()}</span></div>`;
                    }
                    if (frame.deviceName) {
                        info += `<div class="field"><span class="field-name">Nom device:</span> <span class="field-value">${frame.deviceName}</span></div>`;
                    }
                    if (frame.isFeatureCheck && frame.featureData) {
                        info += generateFeatureCheckInfo(frame.featureData);
                    }
                    if (frame.inputData && !frame.isFeatureCheck) {
                        info += `<div class="field"><span class="field-name">Donn√©es entr√©e:</span> <span class="field-value">${frame.inputData}</span></div>`;
                    }
                }
            }
            
            if (frame.checksumValid !== undefined) {
                const checksumClass = frame.checksumValid ? 'checksum-ok' : 'checksum-error';
                info += `<div class="field"><span class="field-name">Checksum:</span> <span class="field-value ${checksumClass}">Re√ßu: 0x${frame.checksumReceived.toString(16).toUpperCase()}, Calcul√©: 0x${frame.checksumCalculated.toString(16).toUpperCase()}</span></div>`;
            }
            
            if (frame.hasError) {
                info += `<div class="error">Erreurs: ${frame.errorMessage}</div>`;
            }
            
            info += '</div>';
            return info;
        }
        
        function updateStats() {
            document.getElementById('stats').style.display = 'grid';
            document.getElementById('totalFrames').textContent = stats.total;
            document.getElementById('commandFrames').textContent = stats.commands;
            document.getElementById('responseFrames').textContent = stats.responses;
            document.getElementById('errorFrames').textContent = stats.errors;
        }
        
        function displayError(message) {
            const container = document.getElementById('framesContainer');
            container.innerHTML = `<div class="error">${message}</div>`;
            container.style.display = 'block';
        }
    </script>
</body>
</html>